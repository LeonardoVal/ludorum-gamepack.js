{"version":3,"sources":["../src/__prologue__.js","../node_modules/@creatartis/ludorum-game-connect4/src/__prologue__.js","../node_modules/@creatartis/ludorum-game-connect4/src/ConnectFour.js","../node_modules/@creatartis/ludorum-game-connect4/src/__epilogue__.js","../node_modules/@creatartis/ludorum-game-colograph/src/__prologue__.js","../node_modules/@creatartis/ludorum-game-colograph/src/Colograph.js","../node_modules/@creatartis/ludorum-game-mancala/src/__prologue__.js","../node_modules/@creatartis/ludorum-game-colograph/src/ui.js","../node_modules/@creatartis/ludorum-game-colograph/src/ai.js","../node_modules/@creatartis/ludorum-game-mancala/src/Mancala.js","../node_modules/@creatartis/ludorum-game-reversi/src/__prologue__.js","../node_modules/@creatartis/ludorum-game-mancala/src/heuristics.js","../node_modules/@creatartis/ludorum-game-mancala/src/__epilogue__.js","../node_modules/@creatartis/ludorum-game-reversi/src/Reversi.js","../node_modules/@creatartis/ludorum-game-reversi/src/Othello.js","../node_modules/@creatartis/ludorum-game-reversi/src/heuristics.js","../src/__epilogue__.js","../node_modules/@creatartis/ludorum-game-reversi/src/__epilogue__.js"],"names":["__init__","base","Sermat","ludorum","exports","__package__","__name__","__dependencies__","__SERMAT__","include","that","this","declare","raiseIf","raise","Iterable","iterable","Game","players","UserInterface","ConnectFour","games","ConnectionGame","name","height","width","lineLength","moves","result","ms","board","string","offset","i","length","charAt","push","activePlayer","next","haps","update","column","row","v","activatePlayers","opponent","__place__","__moves__","__result__","constructor","place","Error","JSON","stringify","lines","asStrings","__lines__","join","indexOf","toString","repeat","victory","tied","static __SERMAT__","identifier","serializer","obj","call","copy","Colograph","args","undefined","initialize","object","defaultValue","array","number","coerce","score","points","shapes","colours","scoreSameShape","scoreDifferentShape","startingPoints","edges","forEach","player","n1_edges","n1","n2","k","hasOwnProperty","zerosumResult","uncoloured","len","move","newColours","Object","assign","adjs","edgeColour","node1","node2","connected","colour1","colour2","static randomGraph","nodeCount","edgeCount","random","Math","max","pair","pair2","range","map","split","toArray","n","choice","static randomGame","params","Randomness","DEFAULT","integer","minimum","maximum","subject","randomGraph","randoms","shapeCount","r","prototype","circularArrangement","radius","angle","PI","round","cos","sin","playerColour","playerColours","toLowerCase","__svgEnvelope__","source","Array","isArray","__svgStyles__","game","p","colour","__svgDefs__","nodeSize","__svgDefCircle__","__svgDefSquare__","__svgDefStar__","__svgDefTriangle__","__svgDefPentagon__","__svgDefHexagon__","__svgDefPolygon__","toSVG","positions","svg","n2s","pos1","pos2","cssClass","pos","heuristics","scoreDifference","Mancala","makeBoard","seeds","houses","isNaN","j","emptyCapture","countRemainingSeeds","store","oppositeHouse","playerHouses","opponentHouses","index","reverse","nextSquare","filter","house","scores","sides","h","sum","_scores","freeTurn","newBoard","slice","nextPlayer","resultBounds","stoneCount","substr","printBoard","lpad","Text","north","northHouses","northStore","south","southHouses","southStore","fromWeights","weights","weightSum","abs","__heuristic__","signum","seedSum","cache","Checkerboard","utils","CheckerboardFromString","Reversi","apply","dual makeBoard","rows","columns","cols","key","line","__MOVE_REGEXPS__","Black","White","dual boardCenter","w","coords","regexps","_moves","boardCenter","coord","square","id","regexp","asString","replace","m","arguments","validMoves","allMoves","piece","valid","clone","walks","DIRECTIONS","EVERY","walk","match","exec","weight","W","B","res_b","squareCount","Othello","activePlayers","heuristicFromWeights","weightCount","heuristic","weightedSum","heuristicFromSymmetricWeights","ceil","left","right","concat","flatten","pieceRatio","playerPieceCount","opponentPieceCount","sq","mobilityRatio","playerMoves","opponentMoves","playerMoveCount","opponentMoveCount","defaultHeuristic","HeuristicPlayer","composite","mancala","colograph"],"mappings":"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","file":"ludorum-gamepack.min.js","sourcesContent":["/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'ludorum-gamepack',\n\t\t__name__: 'ludorum_gamepack',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, ludorum],\n\t\t__SERMAT__: { include: [base, ludorum] }\n\t};\n\n// Imports /////////////////////////////////////////////////////////////////////////////////////////\n/* jshint -W034 */ // Avoid JSHint warning for unnecesary \"use strict\" directive.\n\nvar that = {\n\tbase: base,\n\tSermat: Sermat,\n\tludorum: ludorum\n};\n","/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\t//obj = base.obj,\n\t\t//copy = base.copy,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tIterable = base.Iterable,\n\t\titerable = base.iterable,\n\t\tGame = ludorum.Game,\n\t\tUserInterface = ludorum.players.UserInterface;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'ludorum-game-connect4',\n\t\t__name__: 'ludorum_game_connect4',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, ludorum],\n\t\t__SERMAT__: { include: [base, ludorum] }\n\t};\n","/** # ConnectFour.\n\nImplementation of the [Connect Four game](http://en.wikipedia.org/wiki/Connect_Four), based on\nLudorum's `ConnectionGame`.\n*/\nvar ConnectFour = exports.ConnectFour = declare(ludorum.games.ConnectionGame, {\n\tname: 'ConnectFour',\n\n\t/** The default `height` of the board is 6 ...\n\t*/\n\theight: 6,\n\n\t/** ... and the default `width` of the board is 7.\n\t*/\n\twidth: 7,\n\n\t/** The default `lineLength` to win the game is 4.\n\t*/\n\tlineLength: 4,\n\n\t/** The game's players are Yellow and Red, since these are the classic colours of the pieces.\n\t*/\n\tplayers: ['Yellow', 'Red'],\n\n\t/** The active players `moves()` are the indexes of every column that has not reached the top\n\theight.\n\t*/\n\tmoves: function moves() {\n\t\tvar result = null;\n\t\tif (!this.result()) {\n\t\t\tvar ms = [],\n\t\t\t\tboard = this.board.string,\n\t\t\t\toffset = (this.height - 1) * this.width;\n\t\t\tfor (var i = 0; i < board.length; ++i) {\n\t\t\t\tif (board.charAt(offset + i) === '.') {\n\t\t\t\t\tms.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ms.length > 0) {\n\t\t\t\tresult = {};\n\t\t\t\tresult[this.activePlayer()] = ms;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t/** The `next(moves)` game state drops a piece at the column with the index of the active\n\tplayer's move.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\tboard = this.board.string,\n\t\t\tcolumn = +moves[activePlayer],\n\t\t\theight = this.height,\n\t\t\twidth = this.width;\n\t\tfor (var row = 0; row < height; ++row) {\n\t\t\tif (board.charAt(row * width + column) === '.') {\n\t\t\t\tvar v = activePlayer === this.players[0] ? '0' : '1';\n\t\t\t\tif (update) {\n\t\t\t\t\tthis.activatePlayers(this.opponent());\n\t\t\t\t\tthis.board.__place__([row, column], v);\n\t\t\t\t\tdelete this.__moves__; // Invalidate cached values.\n\t\t\t\t\tdelete this.__result__;\n\t\t\t\t\treturn this;\n\t\t\t\t} else {\n\t\t\t\t\treturn new this.constructor(this.opponent(),\n\t\t\t\t\t\tthis.board.place([row, column], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new Error('Invalid move '+ JSON.stringify(moves) +'!');\n\t},\n\n\tresult: function result() { //FIXME Workaround for bugs in Ludorum v0.2.0.\n\t\tvar lineLength = this.lineLength,\n\t\t\tlines = this.board.asStrings(this.__lines__(this.height, this.width, lineLength)).join(' ');\n\t\tfor (var i = 0; i < this.players.length; ++i) {\n\t\t\tif (lines.indexOf(i.toString(36).repeat(lineLength)) >= 0) {\n\t\t\t\treturn this.victory([this.players[i]]);\n\t\t\t}\n\t\t}\n\t\tif (lines.indexOf('.') < 0) { // No empty squares means a tie.\n\t\t\treturn this.tied();\n\t\t}\n\t\treturn null; // The game continues.\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** Serialization is delegated to the serializer of the parent class.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'ConnectFour',\n\t\tserializer: function serialize_ConnectFour(obj) {\n\t\t\treturn ludorum.games.ConnectionGame.__SERMAT__.serializer(obj);\n\t\t}\n\t},\n}); // declare ConnectFour.\n\n/** Adding Mancala to `ludorum.games`.\n*/\nludorum.games.ConnectFour = ConnectFour;\n\n/** Sermat serialization.\n*/\nConnectFour.__SERMAT__.identifier = exports.__package__ +'.'+ ConnectFour.__SERMAT__.identifier;\nexports.__SERMAT__.include.push(ConnectFour);\nSermat.include(exports);\n","// See __prologue__.js\n\treturn exports;\n}\n","/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\tobj = base.obj,\n\t\tcopy = base.copy,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tIterable = base.Iterable,\n\t\titerable = base.iterable,\n\t\tGame = ludorum.Game,\n\t\tUserInterface = ludorum.players.UserInterface;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'ludorum-game-colograph',\n\t\t__name__: 'ludorum_game_colograph',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, ludorum],\n\t\t__SERMAT__: { include: [base, ludorum] }\n\t};\n","/** # Colograph\n\nImplementation of the game Colograph, a competitive version of the classic [graph colouring problem](http://en.wikipedia.org/wiki/Graph_coloring).\n*/\nvar Colograph = exports.Colograph = declare(Game, {\n\tname: 'Colograph',\n\n\t/** The constructor takes the following arguments:\n\t*/\n\tconstructor: function Colograph(args) {\n\t\t/** + `activePlayer`: There is only one active player per turn, and it is the first player\n\t\t\tby default.\n\t\t*/\n\t\tGame.call(this, args ? args.activePlayer : undefined);\n\t\tbase.initialize(this, args)\n\t\t/** + `colours`: The colour of each node in the graph is given by an array of integers, each\n\t\t\tbeing the node's player index in the players array, or -1 for uncoloured nodes. By\n\t\t\tdefault all nodes are not coloured, which is the initial game state.\n\t\t*/\n\t\t\t.object('colours', { defaultValue: {} })\n\t\t/** + `edges`: The edges of the graph are represented by an array of arrays of integers,\n\t\t\tacting as an adjacency list.\n\t\t*/\n\t\t\t.array('edges', { defaultValue: [[1,3],[2],[3],[]] })\n\t\t/** + `shapes`: Each of the graph's nodes can have a certain shape. This is specified by an\n\t\t\tarray of strings, one for each node.\n\t\t*/\n\t\t\t.array('shapes', { defaultValue: ['circle', 'triangle', 'square', 'star'] })\n\t\t/** + `scoreSameShape=-1`: Score added by each coloured edge that binds two nodes of the\n\t\t\tsame shape.\n\t\t*/\n\t\t\t.number('scoreSameShape', { defaultValue: -1, coerce: true })\n\t\t/** + `scoreDifferentShape=-1`: Score added by each coloured edge that binds two nodes of\n\t\t\tdifferent shapes.\n\t\t*/\n\t\t\t.number('scoreDifferentShape', { defaultValue: -1, coerce: true });\n\t},\n\n\t/** There are two roles in this game: Red and Blue.\n\t*/\n\tplayers: ['Red', 'Blue'],\n\n\t/** Scores are calculated for each player with the edges of their colour. An edge connecting two\n\tnodes of the same colour is considered to be of that colour.\n\t*/\n\tscore: function score() {\n\t\tvar points = {},\n\t\t\tshapes = this.shapes,\n\t\t\tcolours = this.colours,\n\t\t\tscoreSameShape = this.scoreSameShape,\n\t\t\tscoreDifferentShape = this.scoreDifferentShape,\n\t\t\tstartingPoints = this.edges.length;\n\t\tthis.players.forEach(function (player) {\n\t\t\tpoints[player] = startingPoints;\n\t\t});\n\t\titerable(this.edges).forEach(function (n1_edges, n1) {\n\t\t\tn1_edges.forEach(function (n2) {\n\t\t\t\tvar k = n1 +','+ n2;\n\t\t\t\tif (colours.hasOwnProperty(k)) {\n\t\t\t\t\tpoints[colours[k]] += shapes[n1] === shapes[n2] ? scoreSameShape : scoreDifferentShape;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn points;\n\t},\n\n\t/** The game ends when the active player has no moves, i.e. when all nodes in the graph have\n\tbeen coloured. The match is won by the player with the greatest score.\n\t*/\n\tresult: function result() {\n\t\tif (!this.moves()) { // If the active player cannot move, the game is over.\n\t\t\tvar points = this.score(),\n\t\t\t\tplayers = this.players;\n\t\t\treturn this.zerosumResult(points[players[0]] - points[players[1]], players[0]);\n\t\t} else {\n\t\t\treturn null; // The game continues.\n\t\t}\n\t},\n\n\t/** Every non coloured node is a possible move for the active player.\n\t*/\n\tmoves: function moves() {\n\t\tvar colours = this.colours,\n\t\t\tuncoloured = [];\n\t\tfor (var i = 0, len = this.edges.length; i < len; i++) {\n\t\t\tif (!colours.hasOwnProperty(i)) {\n\t\t\t\tuncoloured.push(i);\n\t\t\t}\n\t\t}\n\t\treturn uncoloured.length < 1 ? null : obj(this.activePlayer(), uncoloured);\n\t},\n\n\t/** The result of any move is the colouring of one previously uncoloured node with the active\n\tplayers's colour.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\tmove = moves[activePlayer] |0;\n\t\traiseIf(move < 0 || move >= this.edges.length,\n\t\t\t'Invalid move: node ', move, ' does not exist in ', this, '.');\n\t\traiseIf(this.colours.hasOwnProperty(move),\n\t\t\t'Invalid move: node ', move, ' has already been coloured in ', this, '.');\n\t\tvar newColours = Object.assign(obj(move, activePlayer), this.colours);\n\t\tthis.edges[move].forEach(function (n2) { // Colour edges from the one coloured in this move.\n\t\t\tif (newColours[n2] === activePlayer) {\n\t\t\t\tnewColours[move +','+ n2] = activePlayer;\n\t\t\t}\n\t\t});\n\t\tthis.edges.forEach(function (adjs, n1) { // Colour edges to the one coloured in this move.\n\t\t\tif (n1 !== move && adjs.indexOf(move) >= 0 && newColours[n1] === activePlayer) {\n\t\t\t\tnewColours[n1 +','+ move] = activePlayer;\n\t\t\t}\n\t\t});\n\t\tvar args = {\n\t\t\tactivePlayer: this.opponent(activePlayer),\n\t\t\tcolours: newColours,\n\t\t\tedges: this.edges,\n\t\t\tshapes: this.shapes,\n\t\t\tscoreSameShape: this.scoreSameShape,\n\t\t\tscoreDifferentShape: this.scoreDifferentShape\n\t\t};\n\t\tif (update) {\n\t\t\tthis.constructor(args);\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(args);\n\t\t}\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** Serialization is used in the `toString()` method, but it is also vital for sending the game\n\tstate across a network or the marshalling between the rendering thread and a webworker.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Colograph',\n\t\tserializer: function serialize_Colograph(obj) {\n\t\t\treturn [{\n\t\t\t\tactivePlayer: obj.activePlayer(),\n\t\t\t\tcolours: obj.colours,\n\t\t\t\tedges: obj.edges,\n\t\t\t\tshapes: obj.shapes,\n\t\t\t\tscoreSameShape: obj.scoreSameShape,\n\t\t\t\tscoreDifferentShape: obj.scoreDifferentShape\n\t\t\t}];\n\t\t}\n\t},\n\n\t// ## Game properties. #########################################################################\n\n\t/** `edgeColour(node1, node2)` returns a colour (player index) if the nodes are joined by an\n\tedge, and both have that same colour.\n\t*/\n\tedgeColour: function edgeColour(node1, node2) {\n\t\tvar connected = this.edges[node1].indexOf(node2) >= 0 || this.edges[node2].indexOf(node1) >= 0,\n\t\t\tcolour1 = this.colours[node1],\n\t\t\tcolour2 = this.colours[node2];\n\t\treturn connected && colour1 >= 0 && colour1 === colour2 ? colour1 : -1;\n\t},\n\n\t// ## Graph generation. ########################################################################\n\n\t/** One of the nice features of this game is the variety that comes from chaning the graph on\n\twhich the game is played. `randomGraph` can be used to generate graphs to experiment with.\n\t*/\n\t'static randomGraph': function randomGraph(nodeCount, edgeCount, random) {\n\t\tnodeCount = Math.max(2, +nodeCount >> 0);\n\t\tedgeCount = Math.max(nodeCount - 1, +edgeCount >> 0);\n\t\tvar edges = Iterable.range(nodeCount - 1).map(function (i) {\n\t\t\treturn random.split(1, Iterable.range(i + 1, nodeCount).toArray());\n\t\t}).toArray();\n\t\tfor (var n = edgeCount - (nodeCount - 1), pair, pair2; n > 0; n--) {\n\t\t\tpair = random.choice(edges);\n\t\t\tif (pair[1].length > 0) {\n\t\t\t\tpair2 = random.split(1, pair[1]);\n\t\t\t\tpair[0].push(pair2[0][0]);\n\t\t\t\tpair[1] = pair2[1];\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tedges = edges.map(function (pair) {\n\t\t\treturn pair[0];\n\t\t});\n\t\tedges.push([]); // Last node has no edges.\n\t\treturn edges;\n\t},\n\n\t/** `randomGame(params)` will generates a random Colograph game with a random graph.\n\t*/\n\t'static randomGame': function randomGame(params) {\n\t\tparams = base.initialize({}, params)\n\t\t\t.object('random', { defaultValue: base.Randomness.DEFAULT })\n\t\t\t.integer('nodeCount', { defaultValue: 8, coerce: true })\n\t\t\t.integer('edgeCount', { defaultValue: 11, coerce: true })\n\t\t\t.integer('shapeCount', { defaultValue: 4, coerce: true, minimum: 1, maximum: 4 })\n\t\t\t.array('shapes', { defaultValue: ['circle', 'triangle', 'square', 'star'] })\n\t\t\t.subject;\n\t\treturn new this({\n\t\t\tedges: this.randomGraph(params.nodeCount, params.edgeCount, params.random),\n\t\t\tshapes: params.random.randoms(params.nodeCount, 0, params.shapeCount).map(function (r) {\n\t\t\t\treturn params.shapes[r|0];\n\t\t\t}),\n\t\t\tscoreSameShape: 1\n\t\t});\n\t}\n}); // declare Colograph.\n\n/** Adding Mancala to `ludorum.games`.\n*/\nludorum.games.Colograph = Colograph;\n\n/** Sermat serialization.\n*/\nColograph.__SERMAT__.identifier = exports.__package__ +'.'+ Colograph.__SERMAT__.identifier;\nexports.__SERMAT__.include.push(Colograph);\nSermat.include(exports);\n","/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\t//obj = base.obj,\n\t\t//copy = base.copy,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tIterable = base.Iterable,\n\t\titerable = base.iterable,\n\t\tGame = ludorum.Game,\n\t\tUserInterface = ludorum.players.UserInterface;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'ludorum-game-mancala',\n\t\t__name__: 'ludorum_game_mancala',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, ludorum],\n\t\t__SERMAT__: { include: [base, ludorum] }\n\t};\n","/** # User interface\n\nThe user interface for playtesters is based on [SVG](https://www.w3.org/TR/SVG/).\n*/\n\nObject.assign(Colograph.prototype, {\n\n/** Nodes in the `Colograph` object do not have a defined position. Yet they must be given one if\nthe board is going to be rendered properly. This _arrangement_ methods calculate an array of\npositions for every node in the game, follwing different criteria:\n\n+ `circularArrangement` puts all nodes in a circle of a given `radius`.\n*/\n\tcircularArrangement: function circularArrangement(radius) {\n\t\tradius = radius || 200;\n\t\tvar angle = 2 * Math.PI / this.edges.length;\n\t\treturn this.edges.map(function (adjs, n) {\n\t\t\treturn [Math.round(radius * Math.cos(angle * n)),\n\t\t\t\tMath.round(radius * Math.sin(angle * n))];\n\t\t});\n\t},\n\n\t//TODO More arrangement options.\n\n/** Each player in the game represents a `playerColour`. If the game state has a `playerColours`\nproperty defined, it is assumed it maps players with CSS colour names. Else the players' names in\nlowercase are used as CSS colour names.\n*/\n\tplayerColour: function (player, playerColours) {\n\t\tplayerColours = playerColours || this.playerColours;\n\t\treturn playerColours && playerColours[player] ||\n\t\t\tplayer && (player +'').toLowerCase() || '';\n\t},\n\n/** ## SVG #########################################################################################\n\nThese function implement the generation of Colograph game interfaces based on [Scalable Vector\nGraphics (a.k.a. SVG)](https://www.w3.org/TR/SVG/).\n*/\n\n/** The _envelope_ of the SVG definitions include the processing instruction (`<?xml ... ?>`), the\nSVG's DOCTYPE and the root element `svg`. The `xlink` namespace is used in the `use` elements.\n*/\n\t__svgEnvelope__: function __svgEnvelope__(width, height, source) {\n\t\treturn '<?xml version=\"1.0\" standalone=\"no\"?>\\n'+\n\t\t\t'<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" '+\n\t\t\t\t'\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n'+\n\t\t\t'<svg height=\"'+ height +'px\" width=\"'+ width +'px\" version=\"1.1\"\\n'+\n\t\t\t\t'xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\\n'+\n\t\t\t(Array.isArray(source) ? source.join('\\n\\t') : source) +\n\t\t\t'\\n</svg>';\n\t},\n\n/** The generated SVG for a Colograph game uses CSS styles as much as possible. Two style are\ndefined for each player and the blank state, one for edges and one for nodes.\n*/\n\t__svgStyles__: function __svgStyles__(playerColours) {\n\t\tvar game = this;\n\t\treturn '<style type=\"text/css\" ><![CDATA[\\n'+\n\t\t\t'\\t.blank-node { stroke:black; stroke-width:2px; fill:white; }\\n'+\n\t\t\t'\\t.blank-node:hover { stroke-width:4px; }\\n'+\n\t\t\t'\\t.blank-edge { stroke:black; stroke-width:2px; }\\n'+\n\t\t\tthis.players.map(function (p) { // Embedded CSS Styles\n\t\t\t\tvar colour = game.playerColour(p, playerColours);\n\t\t\t\treturn '\\t.'+ colour +'-node { stroke:black; stroke-width:2px; fill:'+ colour +\n\t\t\t\t\t'}\\n\\t.'+\tcolour +'-edge { stroke:'+ colour +'; stroke-width:2px }';\n\t\t\t}).join('\\n') +\n\t\t\t'\\t]]>\\n\\t</style>\\n';\n\t},\n\n/** All possible node shapes are defined in a `defs` element, so they can be reused. A translate\ntransform is used to put each node in its corresponding possition. Still, `nodeSize` has to be\nprovided, since scaling may lead to weird results.\n*/\n\t__svgDefs__: function __svgDefs__(nodeSize) {\n\t\tnodeSize = nodeSize || 30;\n\t\treturn ['<defs>',\n\t\t\tthis.__svgDefCircle__(nodeSize),\n\t\t\tthis.__svgDefSquare__(nodeSize),\n\t\t\tthis.__svgDefStar__(nodeSize),\n\t\t\tthis.__svgDefTriangle__(nodeSize),\n\t\t\tthis.__svgDefPentagon__(nodeSize),\n\t\t\tthis.__svgDefHexagon__(nodeSize),\n\t\t\t'</defs>'\n\t\t].join('\\n');\n\t},\n\n/** Some of the available shapes are defined as polygons, given the `points` of their vertices.\nThese points are multiplied by `nodeSize`, hence the shape they defined must be centered at (0,0)\nand must have a size of 1.\n*/\n\t__svgDefPolygon__: function __svgDefPolygon__(name, points, nodeSize) {\n\t\tpoints = points.map(function (p) {\n\t\t\treturn [p[0] * nodeSize, p[1] * nodeSize];\n\t\t});\n\t\treturn '\\t<polygon id=\"'+ name +'-node\" points=\"'+ points.join(' ') +'\"/>';\n\t},\n\n/** Available shapes are:\n\t+ `circle`,\n*/\n\t__svgDefCircle__: function __svgDefCircle__(nodeSize) {\n\t\treturn '\\t<circle id=\"circle-node\" r=\"'+ (nodeSize / 2) +'px\" cx=\"0\" cy=\"0\"/>';\n\t},\n\n/** + `square`,\n*/\n\t__svgDefSquare__: function __svgDefSquare__(nodeSize) {\n\t\treturn '\\t<rect id=\"square-node\" width=\"'+ nodeSize +'px\" height=\"'+ nodeSize +'px\"'+\n\t\t\t' x=\"-'+ (nodeSize / 2) +'\" y=\"-'+ (nodeSize / 2) +'\"/>';\n\t},\n\n/** + `triangle` (equilateral),\n*/\n\t__svgDefTriangle__: function __svgDefTriangle__(nodeSize) {\n\t\treturn this.__svgDefPolygon__('triangle', [\n\t\t\t\t[-0.50,+0.44], [+0.00,-0.44], [+0.50,+0.44]\n\t\t\t], nodeSize);\n\t},\n\n/** + `star` (five points),\n*/\n\t__svgDefStar__: function __svgDefStar__(nodeSize) {\n\t\treturn this.__svgDefPolygon__('star', [\n\t\t\t\t[+0.00,-0.48], [+0.12,-0.10], [+0.50,-0.10], [+0.20,+0.10], [+0.30,+0.48],\n\t\t\t\t[+0.00,+0.26], [-0.30,+0.48], [-0.20,+0.10], [-0.50,-0.10], [-0.12,-0.10]\n\t\t\t], nodeSize);\n\t},\n\n/** + `pentagon` (regular),\n*/\n\t__svgDefPentagon__: function __svgDefPentagon__(nodeSize) {\n\t\treturn this.__svgDefPolygon__('pentagon', [\n\t\t\t\t[+0.00,-0.48], [+0.50,-0.10], [+0.30,+0.48], [-0.30,+0.48], [-0.50,-0.10]\n\t\t\t], nodeSize);\n\t},\n\n/** + `hexagon` (regular),\n*/\n\t__svgDefHexagon__: function __svgDefHexagon__(nodeSize) {\n\t\treturn this.__svgDefPolygon__('pentagon', [\n\t\t\t\t[+0.00,-0.50], [+0.42,-0.24], [+0.42,+0.24], [+0.00,+0.50], [-0.42,+0.24],\n\t\t\t\t[-0.42,-0.24]\n\t\t\t], nodeSize);\n\t},\n\n/** The method `toSVG` generates the SVG representation of a Colograph game state.\n*/\n\ttoSVG: function toSVG(width, height, nodeSize, positions) {\n\t\twidth = width || 400;\n\t\theight = height || 400;\n\t\tpositions = positions || this.circularArrangement(Math.max(width, height) / 2.5);\n\t\tvar game = this,\n\t\t\tcolours = this.colours,\n\t\t \tsvg = [\n\t\t\t\tthis.__svgStyles__(),\n\t\t\t\tthis.__svgDefs__(nodeSize),\n\t\t\t\t'\\t<g id=\"colograph\" transform=\"translate('+ (width / 2) +','+ (height / 2) +')\">'\n\t\t\t];\n\t\t/** Edges are drawn before the nodes, so they do not appear in front of them.\n\t\t*/\n\t\tthis.edges.forEach(function (n2s, n1) {\n\t\t\tvar pos1 = positions[n1];\n\t\t\tn2s.forEach(function (n2) {\n\t\t\t\tvar pos2 = positions[n2],\n\t\t\t\t\tcolour = colours[n1 +','+ n2],\n\t\t\t\t\tcssClass = (game.playerColour(colour) || 'blank') +'-edge';\n\t\t\t\tsvg.push('\\t<line class=\"'+ cssClass +'\" x1=\"'+ pos1[0] +'\" y1=\"'+ pos1[1] +\n\t\t\t\t\t'\" x2=\"'+ pos2[0] +'\" y2=\"'+ pos2[1] +'\"/>');\n\t\t\t});\n\t\t});\n\t\t/** Node shapes reuse the definitions generated before, and are put in place with a\n\t\ttranslation transform.\n\t\t*/\n\t\tvar shapes = this.shapes;\n\t\tthis.edges.forEach(function (adjs, n) {\n\t\t\tvar pos = positions[n],\n\t\t\t\tcolour = colours[n],\n\t\t\t\tcssClass = (game.playerColour(colour) || 'blank') +'-node';\n\t\t\tsvg.push('<use id=\"node'+ n +'\" xlink:href=\"#'+ shapes[n] +'-node\" '+\n\t\t\t\t'transform=\"translate('+ pos.join(',') +')\" class=\"'+ cssClass +'\" '+\n\t\t\t\t'data-ludorum-move=\"'+ n +'\"/>');\n\t\t});\n\t\tsvg.push('\\t</g>');\n\t\treturn this.__svgEnvelope__(width, height, svg);\n\t} // Colograph.toSVG\n}); //\n","// # AI for Colograph.\n\n// ## Heuristics ###################################################################################\n\n/** `heuristics` is a namespace for heuristic evaluation functions to be used with artificial\nintelligence methods such as Minimax.\n*/\nColograph.heuristics = {\n\t/** `scoreDifference(game, player)` is a simple heuristic that uses the current score.\n\t*/\n\tscoreDifference: function scoreDifference(game, player) {\n\t\tvar score = game.score(),\n\t\t\tresult = 0;\n\t\tfor (var p in score) {\n\t\t\tresult += p === player ? score[p] : -score[p];\n\t\t}\n\t\treturn result / game.edges.length / 2;\n\t}\n}; // Colograph.heuristics\n","/** # Mancala\n\nImplementation of the [Kalah](http://en.wikipedia.org/wiki/Kalah) member of the\n[Mancala family of games](http://en.wikipedia.org/wiki/Mancala).\n*/\nvar Mancala = exports.Mancala = declare(Game, {\n\tname: 'Mancala',\n\n\t/** The constructor takes the `activePlayer` (`\"North\"` by default) and the board as an array of\n\tintegers (initial board by default).\n\t*/\n\tconstructor: function Mancala(activePlayer, board){\n\t\tGame.call(this, activePlayer);\n\t\tthis.board = board || this.makeBoard();\n\t},\n\n\t/** `makeBoard(seeds, houses)` builds an array for the given amounts of houses and seeds per\n\thouse. By default 4 seeds and 6 houses per player are assumed.\n\t*/\n\tmakeBoard: function makeBoard(seeds, houses){\n\t\tseeds = isNaN(seeds) ? 4 : +seeds;\n\t\thouses = isNaN(houses) ? 6 : +houses;\n\t\tvar result = [];\n\t\tfor(var j = 0; j < 2; j++){\n\t\t\tfor(var i = 0; i < houses; i++){\n\t\t\t\tresult.push(seeds);\n\t\t\t}\n\t\t\tresult.push(0);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/** The players' roles in a Mancala match are `\"North\"` and `\"South\"`.\n\t*/\n\tplayers: [\"North\", \"South\"],\n\n\t/** If `emptyCapture` is true, making a capture only moves the active player's seed to his\n\tstore, and the opponents seeds are not captured. By default this is false.\n\t*/\n\temptyCapture: false,\n\n\t/** If `countRemainingSeeds` is true, at the end of the game if a player has seeds on his\n\thouses, those seeds are included in his score. This is the default behaviour.\n\t*/\n\tcountRemainingSeeds: true,\n\n\t// ## Game state information ###################################################################\n\n\t/** `store(player)` returns the index in this game's board of the player's store.\n\t*/\n\tstore: function store(player){\n\t\tswitch (this.players.indexOf(player)) {\n\t\t\tcase 0: return this.board.length / 2 - 1; // Store of North.\n\t\t\tcase 1: return this.board.length - 1; // Store of South.\n\t\t\tdefault: throw new Error(\"Invalid player \"+ player +\".\");\n\t\t}\n\t},\n\n\t/** `houses(player)` returns an array with the indexes of the player's houses in this game's\n\tboard.\n\t*/\n\thouses: function houses(player){\n\t\tswitch (this.players.indexOf(player)) {\n\t\t\tcase 0: return Iterable.range(0, this.board.length / 2 - 1).toArray(); // Store of North.\n\t\t\tcase 1: return Iterable.range(this.board.length / 2, this.board.length - 1).toArray(); // Store of South.\n\t\t\tdefault: throw new Error(\"Invalid player \"+ player +\".\");\n\t\t}\n\t},\n\n\t/** The house in front of a players house is calculated by `oppositeHouse(player, i)`. It\n\treturns the index of the opposite house of `i` for the given player, or a negative if `i` is not\n\ta house of the given player. This is necessary for resolving captures.\n\t*/\n\toppositeHouse: function oppositeHouse(player, i) {\n\t\tvar playerHouses = this.houses(player),\n\t\t\topponentHouses = this.houses(this.opponent(player)),\n\t\t\tindex = playerHouses.indexOf(i);\n\t\treturn index < 0 ? index : opponentHouses.reverse()[index];\n\t},\n\n\t/** The flow of seeds on the board is defined by `nextSquare(player, i)`. It returns the index\n\tof the square following `i` for the given player.\n\t*/\n\tnextSquare: function nextSquare(player, i){\n\t\tdo {\n\t\t\ti = (i + 1) % this.board.length;\n\t\t} while (i === this.store(this.opponent(player)));\n\t\treturn i;\n\t},\n\n\t// ## Game logic ###############################################################################\n\n\t/** A move for a Mancala player is an index of the square in the board.\n\t*/\n\tmoves: function moves(){\n\t\tif (this.result()) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tvar board = this.board,\n\t\t\t\tresult = {},\n\t\t\t\tactivePlayer = this.activePlayer();\n\t\t\tresult[activePlayer] = this.houses(activePlayer).filter(function(house){\n\t\t\t\treturn board[house] > 0; // The house has seeds.\n\t\t\t});\n\t\t\treturn result[activePlayer].length > 0 ? result : null;\n\t\t}\n\t},\n\n\t/** The game ends when the active player cannot move. The `score()` for each player is the seed\n\tcount of its store and (if `countRemainingSeeds` is true) the houses on its side of the board.\n\t*/\n\tscores: function scores() {\n\t\tvar game = this,\n\t\t\tboard = this.board,\n\t\t\tsides = this.players.map(function (player) {\n\t\t\t\treturn iterable(game.houses(player)).map(function (h) {\n\t\t\t\t\treturn board[h];\n\t\t\t\t}).sum();\n\t\t\t});\n\t\tif (sides[0] > 0 && sides[1] > 0) { // Both sides have seeds.\n\t\t\treturn null;\n\t\t} else { // One side has no seeds.\n\t\t\tvar _scores = {};\n\t\t\tthis.players.forEach(function (player, i) {\n\t\t\t\t_scores[player] = board[game.store(player)] + game.countRemainingSeeds * sides[i];\n\t\t\t});\n\t\t\treturn _scores;\n\t\t}\n\t},\n\n\t/** The result for each player is the difference between its score and the opponent's.\n\t*/\n\tresult: function result() {\n\t\tvar scores = this.scores(),\n\t\t\tplayers = this.players;\n\t\treturn scores && this.zerosumResult(scores[players[0]] - scores[players[1]], players[0]);\n\t},\n\n\t/** The `next(moves)` game state implies taking all seeds from the selected house and moving\n\tthem across the board, placing one seed at each step. A player can pass through its store but\n\tnot through the opponent's. If the move ends at the active player's store, then it has another\n\tmove. If it ends at an empty house, capture may occur.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\tmove = +moves[activePlayer],\n\t\t\tnewBoard = this.board.slice(0),\n\t\t\tseeds = newBoard[move],\n\t\t\tfreeTurn = false,\n\t\t\tstore, oppositeHouse;\n\t\traiseIf(seeds < 1, \"Invalid move \", move, \" for game \", this);\n\t\t// Move.\n\t\tnewBoard[move] = 0;\n\t\tfor (; seeds > 0; seeds--) {\n\t\t\tmove = this.nextSquare(activePlayer, move);\n\t\t\tnewBoard[move]++;\n\t\t}\n\t\t// Free turn if last square of the move is the player's store.\n\t\tfreeTurn = move == this.store(activePlayer);\n\t\t// Capture.\n\t\tif (!freeTurn) {\n\t\t\toppositeHouse = this.oppositeHouse(activePlayer, move);\n\t\t\tif (oppositeHouse >= 0 && newBoard[move] == 1 && newBoard[oppositeHouse] > 0) {\n\t\t\t\tstore = this.store(activePlayer);\n\t\t\t\tnewBoard[store]++;\n\t\t\t\tnewBoard[move] = 0;\n\t\t\t\tif (!this.emptyCapture) {\n\t\t\t\t\tnewBoard[store] += newBoard[oppositeHouse];\n\t\t\t\t\tnewBoard[oppositeHouse] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar nextPlayer = freeTurn ? activePlayer : this.opponent();\n\t\tif (update) {\n\t\t\tthis.activatePlayers(nextPlayer);\n\t\t\tthis.board = newBoard;\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(nextPlayer, newBoard);\n\t\t}\n\t},\n\n\t/** The `resultBounds` for a Mancala game are estimated with the total number of seeds in the\n\tboard. It is very unlikely to get these result though.\n\t*/\n\tresultBounds: function resultBounds() {\n\t\tvar stoneCount = iterable(this.board).sum();\n\t\treturn [-stoneCount,+stoneCount];\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** Serialization is used in the `toString()` method, but it is also vital for sending the game\n\tstate across a network or the marshalling between the rendering thread and a webworker.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: exports.__package__ +'.Mancala',\n\t\tserializer: function serialize_Mancala(obj) {\n\t\t\treturn [obj.activePlayer(), obj.board];\n\t\t}\n\t},\n\n\tidentifier: function identifier() {\n\t\treturn this.activePlayer().charAt(0) + this.board.map(function (n) {\n\t\t\treturn ('00'+ n.toString(36)).substr(-2);\n\t\t}).join('');\n\t},\n\n\t/** `printBoard()` creates a text (ASCII) version of the board.\n\t*/\n\tprintBoard: function printBoard() {\n\t\tvar game = this,\n\t\t\tlpad = base.Text.lpad,\n\t\t\tnorth = this.players[0],\n\t\t\tnorthHouses = this.houses(north).map(function (h) {\n\t\t\t\treturn lpad(''+ game.board[h], 2, '0');\n\t\t\t}).reverse(),\n\t\t\tnorthStore = lpad(''+ this.board[this.store(north)], 2, '0'),\n\t\t\tsouth = this.players[1],\n\t\t\tsouthHouses = this.houses(south).map(function (h) {\n\t\t\t\treturn lpad(''+ game.board[h], 2, '0');\n\t\t\t}),\n\t\t\tsouthStore = lpad(''+ this.board[this.store(south)], 2, '0');\n\t\treturn \"   \"+ northHouses.join(\" | \") +\"   \\n\"+\n\t\t\tnorthStore +\" \".repeat(northHouses.length * 2 + (northHouses.length - 1) * 3 + 2) + southStore +\"\\n\"+\n\t\t\t\"   \"+ southHouses.join(\" | \") +\"   \";\n\t}\n}); // declare Mancala.\n\n// ## Mancala type initialization ##################################################################\n\n/** The `makeBoard` can also be used without an instance of Mancala.\n*/\nMancala.makeBoard = Mancala.prototype.makeBoard;\n\n/** Adding Mancala to `ludorum.games`.\n*/\nludorum.games.Mancala = Mancala;\n\n/** Sermat serialization.\n*/\nexports.__SERMAT__.include.push(Mancala);\nSermat.include(exports);\n","/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\tobj = base.obj,\n\t\tcopy = base.copy,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tIterable = base.Iterable,\n\t\titerable = base.iterable,\n\t\tGame = ludorum.Game,\n\t\tCheckerboard = ludorum.utils.Checkerboard,\n\t\tCheckerboardFromString = ludorum.utils.CheckerboardFromString,\n\t\tUserInterface = ludorum.players.UserInterface;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'ludorum-game-reversi',\n\t\t__name__: 'ludorum_game_reversi',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, ludorum],\n\t\t__SERMAT__: { include: [base, ludorum] }\n\t};\n","/** # Heuristics for Mancala\n\n`Mancala.heuristics` is a bundle of helper functions to build heuristic evaluation functions for\nthis game.\n*/\nMancala.heuristics = {\n\t/** + `heuristicFromWeights(weights=default weights)` builds an heuristic evaluation\n\t\tfunction from weights for each square in the board. The result of the function is the\n\t\tnormalized weighted sum.\n\t*/\n\tfromWeights: function fromWeights(weights) {\n\t\tvar weightSum = iterable(weights).map(Math.abs).sum();\n\t\tfunction __heuristic__(game, player) {\n\t\t\tvar seedSum = 0, signum, result;\n\t\t\tswitch (game.players.indexOf(player)) {\n\t\t\t\tcase 0: signum = 1; break; // North.\n\t\t\t\tcase 1: signum = -1; break; // South.\n\t\t\t\tdefault: throw new Error(\"Invalid player \"+ player +\".\");\n\t\t\t}\n\t\t\tresult = iterable(game.board).map(function (seeds, i) {\n\t\t\t\tseedSum += seeds;\n\t\t\t\treturn seeds * weights[i]; //TODO Normalize weights before.\n\t\t\t}).sum() / weightSum / seedSum * signum;\n\t\t\treturn result;\n\t\t}\n\t\t__heuristic__.weights = weights;\n\t\treturn __heuristic__;\n\t}\n};\n\n/** The `DEFAULT` heuristic for Mancala is based on weights for each square. Stores are worth 5 and\nhouses 1, own possitive and the opponent's negative.\n*/\nMancala.heuristics.DEFAULT = Mancala.heuristics.fromWeights(\n\t[+1,+1,+1,+1,+1,+1,+5, /**/ -1,-1,-1,-1,-1,-1,-5]\n);\n","// See __prologue__.js\n\treturn exports;\n}\n","/** # Reversi\n\nImplementation of [Reversi](http://en.wikipedia.org/wiki/Reversi) for Ludorum.\n*/\nvar Reversi = exports.Reversi = declare(Game, {\n\tname: 'Reversi',\n\n\t/** The constructor takes the `activePlayer` (`\"Black\"` by default) and a board (initial board\n\tby default). The board is represented by an array of two integers and a string:\n\t`[rows, columns, string]`. The string must have:\n\n\t+ `'W'` for every square occupied by a white piece.\n\t+ `'B'` for every square occupied by a black piece.\n\t+ `'.'` for every empty square.\n\t*/\n\tconstructor: function Othello(activePlayer, board){\n\t\tGame.call(this, activePlayer);\n\t\tthis.board = this.makeBoard.apply(this, board || []);\n\t},\n\n\t/** `makeBoard(rows=8, columns=8, string)` is used to build the initial board.\n\t*/\n\t'dual makeBoard': function makeBoard(rows, columns, string){ //FIXME\n\t\trows = isNaN(rows) ? 8 : +rows;\n\t\tcolumns = isNaN(columns) ? 8 : +columns;\n\t\traiseIf(rows < 4 || columns < 4 || rows % 2 || columns % 2,\n\t\t\t\"An Reversi board must have even dimensions greater than 3.\");\n\t\tif (typeof string === 'string') {\n\t\t\treturn new CheckerboardFromString(rows, columns, string);\n\t\t} else {\n\t\t\treturn new CheckerboardFromString(rows, columns);\n\t\t}\n\t},\n\n\t/** The game is played by two players: Black and White. Black moves first.\n\t*/\n\tplayers: [\"Black\", \"White\"],\n\n\t/** Much of the move calculations are based on the possible lines in the board. These are\n\tcalculated and cached by the `lines(rows, cols)` function.\n\t*/\n\tlines: (function (cache) {\n\t\treturn function lines(rows, cols) {\n\t\t\tvar key = rows +'x'+ cols,\n\t\t\t\tresult = cache[key];\n\t\t\tif (typeof result === 'undefined') {\n\t\t\t\tresult = cache[key] = new Checkerboard(rows, cols).lines().map(function(line) {\n\t\t\t\t\treturn line.toArray();\n\t\t\t\t}, function(line){\n\t\t\t\t\treturn line.length > 2;\n\t\t\t\t}).toArray();\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t})({}),\n\n\t/** Another optimization in the move logic uses regular expressions to match patterns in the\n\tboard. These are predefined as a _class_ member.\n\t*/\n\t__MOVE_REGEXPS__: {\n\t\t\"Black\": [/\\.W+B/g, /BW+\\./g],\n\t\t\"White\": [/\\.B+W/g, /WB+\\./g]\n\t},\n\n\t/** The board's center is defined by the coordinates of the middle four squares.\n\t*/\n\t'dual boardCenter': function boardCenter(board) {\n\t\tboard = board || this.board;\n\t\tvar w = board.width,\n\t\t\th = board.height;\n\t\treturn [[h/2, w/2-1], [h/2-1, w/2], [h/2, w/2], [h/2-1, w/2-1]];\n\t},\n\n\t/** A move always places a piece in an empty square. If there are empty square at the center of\n\tthe board, the active player must place a piece in one of them. Else, a piece can be placed if\n\tand only if by doing so one or more lines of the opponent's pieces get enclosed between pieces\n\tof the active player.\n\t*/\n\tmoves: function moves(player){\n\t\tplayer = player || this.activePlayer();\n\t\tif (this.hasOwnProperty('__moves'+ player +'__')) {\n\t\t\treturn this['__moves'+ player +'__'];\n\t\t}\n\t\tvar board = this.board,\n\t\t\tcoords = {},\n\t\t\tregexps = this.__MOVE_REGEXPS__[player];\n\t\tvar _moves = this.boardCenter().filter(function (coord) {\n\t\t\t\treturn board.square(coord) === '.';\n\t\t\t});\n\t\tif (_moves.length < 1) {\n\t\t\tthis.lines(board.height, board.width).forEach(function(line){\n\t\t\t\tregexps.forEach(function (regexp) {\n\t\t\t\t\tboard.asString(line).replace(regexp, function(m, i){\n\t\t\t\t\t\tvar coord = m.charAt(0) === \".\" ? line[i] : line[m.length - 1 + i];\n\t\t\t\t\t\tcoords[coord] = coord;\n\t\t\t\t\t\treturn m;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t\tfor (var id in coords) {\n\t\t\t\t_moves.push(coords[id]);\n\t\t\t}\n\t\t}\n\t\t_moves = _moves.length > 0 ? obj(player, _moves) : null;\n\t\tif (arguments.length < 1) {\n\t\t\treturn this['__moves'+ player +'__'] = _moves; // Cache the result.\n\t\t}\n\t\treturn _moves;\n\t},\n\n\tvalidMoves: function validMoves(moves) {\n\t\tvar allMoves = this.moves();\n\t\tfor (var player in allMoves) {\n\t\t\tif (!moves.hasOwnProperty(player)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar validMove = allMoves[player].join('\\n').indexOf(moves[player] +'') >= 0;\n\t\t\tif (!validMove) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\t/** When the active player encloses one or more lines of opponent's pieces between two of its\n\town, all those are turned into active player's pieces.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tif (!this.validMoves(moves)) {\n\t\t\traise(\"Invalid moves \"+ JSON.stringify(moves) +\"!\");\n\t\t}\n\t\tvar board = this.board.clone(),\n\t\t\tactivePlayer = this.activePlayer(),\n\t\t\tmove = moves[activePlayer],\n\t\t\tpiece, valid;\n\t\tif (activePlayer == this.players[0]) {\n\t\t\tpiece = \"B\";\n\t\t\tvalid = /^W+B/;\n\t\t} else {\n\t\t\tpiece = \"W\";\n\t\t\tvalid = /^B+W/;\n\t\t}\n\t\tif (this.boardCenter().join('\\n').indexOf(move +'') >= 0) { // Place piece at center.\n\t\t\tboard.__place__(move, piece);\n\t\t} else {\n\t\t\tboard.walks(move, Checkerboard.DIRECTIONS.EVERY).forEach(function (walk){\n\t\t\t\tvar match = valid.exec(board.asString(walk).substr(1));\n\t\t\t\tif (match){\n\t\t\t\t\twalk.toArray().slice(0, match[0].length).forEach(function(coord){\n\t\t\t\t\t\tboard.__place__(coord, piece);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (update) {\n\t\t\tthis.constructor(this.opponent(), [board.height, board.width, board.string]);\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(this.opponent(), [board.height, board.width, board.string]);\n\t\t}\n\t},\n\n\t/** A match ends when the active player cannot move. The winner is the one with more pieces of\n\tits color in the board at the end.\n\t*/\n\tresult: function result() {\n\t\tif (this.moves()) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tvar weight = {\"W\": -1, \"B\": 1},\n\t\t\t\tres_b = iterable(this.board.string).map(function(m){\n\t\t\t\t\treturn weight[m] || 0;\n\t\t\t\t}).sum();\n\t\t\treturn this.zerosumResult(res_b, \"Black\");\n\t\t}\n\t},\n\n\t/** The actual score is calculated as the difference in piece count. This means that the maximum\n\tvictory (maybe impossible) is to fill the board with pieces of only one colour.\n\t*/\n\tresultBounds: function resultBounds() {\n\t\tvar squareCount = this.board.width * this.board.height;\n\t\treturn [-squareCount, +squareCount];\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** The game state serialization simply contains the constructor arguments.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: exports.__package__ +'.Reversi',\n\t\tserializer: function serialize_Reversi(obj) {\n\t\t\treturn [obj.activePlayer(), [obj.board.height, obj.board.width, obj.board.string]];\n\t\t}\n\t}\n}); // declare Reversi.\n\n/** Adding Reversi to `ludorum.games`.\n*/\nludorum.games.Reversi = Reversi;\n\n/** Sermat serialization.\n*/\nexports.__SERMAT__.include.push(Reversi);\n","/** # Othello\n\nImplementation of the [Othello variant of Reversi](http://www.worldothello.org/?q=content/reversi-versus-othello)\nfor Ludorum.\n*/\nvar Othello = exports.Othello = declare(Reversi, {\n\tname: 'Reversi',\n\n\t/** One main difference between Reversi and Othello is that is a player has no moves, the turn\n\tpasses to the other player. A match ends only when both players cannot move.\n\t*/\n\tconstructor: function Othello(activePlayer, board){\n\t\tReversi.call(this, activePlayer, board);\n\t\tif (!this.moves()) {\n\t\t\tvar opponent = this.opponent();\n\t\t\tif (this.moves(opponent)) {\n\t\t\t\tthis.activePlayers = [opponent];\n\t\t\t}\n\t\t}\n\t},\n\n\t/** `makeBoard(rows=8, columns=8, string)` is used to build the initial board. The starting\n\tboard of Othello is not empty, like Reversi. The four center squares are defined.\n\t*/\n\t'dual makeBoard': function makeBoard(rows, columns, string){\n\t\trows = isNaN(rows) ? 8 : +rows;\n\t\tcolumns = isNaN(columns) ? 8 : +columns;\n\t\traiseIf(rows < 4 || columns < 4 || rows % 2 || columns % 2,\n\t\t\t\"An Othello board must have even dimensions greater than 3.\");\n\t\tif (typeof string === 'string') {\n\t\t\treturn new CheckerboardFromString(rows, columns, string);\n\t\t} else {\n\t\t\treturn new CheckerboardFromString(rows, columns)\n\t\t\t\t.__place__([rows / 2, columns / 2 - 1], \"W\")\n\t\t\t\t.__place__([rows / 2 - 1, columns / 2], \"W\")\n\t\t\t\t.__place__([rows / 2, columns / 2], \"B\")\n\t\t\t\t.__place__([rows / 2 - 1, columns / 2 - 1], \"B\");\n\t\t}\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** The game state serialization simply contains the constructor arguments.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: exports.__package__ +'.Othello',\n\t\tserializer: function serialize_Othello(obj) {\n\t\t\treturn [obj.activePlayer(), [obj.board.height, obj.board.width, obj.board.string]];\n\t\t}\n\t}\n}); // declare Othello.\n\n/** Adding Othello to `ludorum.games`.\n*/\nludorum.games.Othello = Othello;\n\n/** Sermat serialization.\n*/\nexports.__SERMAT__.include.push(Othello);\n","/** # Heuristics for Mancala\n\n`Othello.heuristics` is a bundle of helper functions to build heuristic evaluation functions for\nthis game.\n*/\nvar heuristics = exports.heuristics = {\n\t/** `heuristicFromWeights(weights)` returns an heuristic function that may be used with any\n\theuristic based player. Weights are normalized, so the result is in (-1,+1) (exclusively).\n\t*/\n\theuristicFromWeights: function heuristicFromWeights(weights) {\n\t\tvar weightCount = weights.length,\n\t\t\tweightSum = iterable(weights).map(Math.abs).sum(); // Used to normalize the sum.\n\t\tvar heuristic = function __heuristic__(game, player) {\n\t\t\tvar board = game.board;\n\t\t\traiseIf(board.height * board.width !== weightCount, \"Wrong amount of weights!\");\n\t\t\treturn board.weightedSum(weights, {\n\t\t\t\t'W': player.charAt(0) === 'W' ? 1 : -1,\n\t\t\t\t'B': player.charAt(0) === 'B' ? 1 : -1\n\t\t\t}) / weightSum;\n\t\t};\n\t\theuristic.weights = weights;\n\t\treturn heuristic;\n\t},\n\n\t/** `heuristicFromSymmetricWeights(weights)` is similar to `heuristicFromWeights()` but\n\tinstead of demanding a weight for every square in the board, it uses only the upper left\n\tquadrant and builds the rest by symmetry. Hence only a quarter of the weights is required.\n\t*/\n\theuristicFromSymmetricWeights: function heuristicFromSymmetricWeights(weights, rows, columns) {\n\t\trows = isNaN(rows) ? 8 : rows | 0;\n\t\tcolumns = isNaN(columns) ? 8 : columns | 0;\n\t\tvar width = Math.ceil(rows / 2);\n\t\traiseIf(width * Math.ceil(columns / 2) > weights.length, \"Not enough weights!\");\n\t\tweights = Iterable.range(columns).map(function (column) {\n\t\t\tvar i = column < columns / 2 ? column : columns - column - 1,\n\t\t\t\tleft = i * width,\n\t\t\t\tright = (i + 1) * width;\n\t\t\treturn weights.slice(left, right)\n\t\t\t\t.concat(weights.slice(left, right - rows % 2).reverse());\n\t\t}).flatten().toArray();\n\t\treturn this.heuristicFromWeights(weights);\n\t},\n\n\t/** `pieceRatio(game, player)` is an heuristic criteria based on the difference of the piece\n\tcounts of both players.\n\t*/\n\tpieceRatio: function pieceRatio(game, player) {\n\t\tvar playerPieceCount = 0, opponentPieceCount = 0;\n\t\titerable(game.board.string).forEach(function (sq) {\n\t\t\tif (sq !== '.') {\n\t\t\t\tif (sq === player.charAt(0)) {\n\t\t\t\t\t++playerPieceCount;\n\t\t\t\t} else {\n\t\t\t\t\t++opponentPieceCount;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn (playerPieceCount - opponentPieceCount) / (playerPieceCount + opponentPieceCount) || 0;\n\t},\n\n\t/** `mobilityRatio(game, player)` is an heuristic criteria based on the difference of the\n\tmove counts of both players.\n\t*/\n\tmobilityRatio: function mobilityRatio(game, player) {\n\t\tvar opponent = game.opponent(player),\n\t\t\tplayerMoves = game.moves(player),\n\t\t\topponentMoves = game.moves(opponent),\n\t\t\tplayerMoveCount = playerMoves && playerMoves[player] && playerMoves[player].length || 0,\n\t\t\topponentMoveCount = opponentMoves && opponentMoves[opponent] && opponentMoves[opponent].length || 0;\n\t\treturn (playerMoveCount - opponentMoveCount) / (playerMoveCount + opponentMoveCount) || 0;\n\t}\n};\n\n/** The default heuristic combines piece and mobility ratios with weights that ponder corners and\nborders but penalizes the squares next to the corners.\n*/\nheuristics.defaultHeuristic = ludorum.players.HeuristicPlayer.composite(\n\theuristics.heuristicFromSymmetricWeights(\n\t\t[+9,-3,+3,+3, -3,-3,-1,-1, +3,-1,+1,+1, +3,-1,+1,+1]\n\t), 0.6,\n\theuristics.pieceRatio, 0.2,\n\theuristics.mobilityRatio, 0.2\n);\n","// See __prologue__.js\n\texports.mancala = {\n\t\tMancala: that['ludorum-game-mancala'].Mancala\n\t};\n\texports.colograph = {\n\t\tColograph: that['ludorum-game-colograph'].Colograph\n\t};\n\texports.connect4 = {\n\t\tConnectFour: that['ludorum-game-connect4'].ConnectFour\n\t};\n\texports.reversi = {\n\t\tReversi: that['ludorum-game-reversi'].Reversi,\n\t\tOthello: that['ludorum-game-reversi'].Othello\n\t};\n\n\treturn exports;\n}\n","// See __prologue__.js\n\tSermat.include(exports);\n\t\n\treturn exports;\n}\n"]}